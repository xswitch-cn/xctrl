// Code generated by protoc-gen-stack. DO NOT EDIT.
// source: proto/xctrl/xctrl.proto

package xctrl

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

import (
	context "context"
	api "git.xswitch.cn/xswitch/xctrl/xctrl/api"
	client "git.xswitch.cn/xswitch/xctrl/xctrl/client"
	errors "git.xswitch.cn/xswitch/xctrl/xctrl/errors"
	server "git.xswitch.cn/xswitch/xctrl/xctrl/server"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Reference imports to suppress errors if they are not otherwise used.
var _ api.Endpoint
var _ context.Context
var _ time.Duration
var _ client.Option
var _ server.Option
var _ errors.Error

// Api Endpoints for XNode service

func NewXNodeEndpoints() []*api.Endpoint {
	return []*api.Endpoint{}
}

// Client API for XNode service

type XNodeService interface {
	// 外呼
	Dial(ctx context.Context, in *DialRequest, opts ...client.CallOption) (*DialResponse, error)
	// 应答,
	Answer(ctx context.Context, in *AnswerRequest, opts ...client.CallOption) (*Response, error)
	// 接管呼叫，被接管的呼叫将会在10s后挂断
	Accept(ctx context.Context, in *AcceptRequest, opts ...client.CallOption) (*Response, error)
	// 播放一个文件或TTS
	Play(ctx context.Context, in *PlayRequest, opts ...client.CallOption) (*Response, error)
	// 停止当前正在执行的API
	Stop(ctx context.Context, in *StopRequest, opts ...client.CallOption) (*Response, error)
	// 广播
	Broadcast(ctx context.Context, in *BroadcastRequest, opts ...client.CallOption) (*Response, error)
	// 设置静音
	Mute(ctx context.Context, in *MuteRequest, opts ...client.CallOption) (*Response, error)
	// 录音
	Record(ctx context.Context, in *RecordRequest, opts ...client.CallOption) (*RecordResponse, error)
	// 挂断当前UUID
	Hangup(ctx context.Context, in *HangupRequest, opts ...client.CallOption) (*Response, error)
	// 在把当前呼叫桥接（发起）另一个呼叫
	Bridge(ctx context.Context, in *BridgeRequest, opts ...client.CallOption) (*Response, error)
	// 桥接两个呼叫
	ChannelBridge(ctx context.Context, in *ChannelBridgeRequest, opts ...client.CallOption) (*Response, error)
	// 将桥接的呼叫分开
	UnBridge(ctx context.Context, in *Request, opts ...client.CallOption) (*Response, error)
	// 将桥接的呼叫分开
	UnBridge2(ctx context.Context, in *Request, opts ...client.CallOption) (*Response, error)
	// 呼叫保持/取消保持
	Hold(ctx context.Context, in *HoldRequest, opts ...client.CallOption) (*Response, error)
	// 转移（待定）
	Transfer(ctx context.Context, in *TransferRequest, opts ...client.CallOption) (*Response, error)
	// 三方通话
	ThreeWay(ctx context.Context, in *ThreeWayRequest, opts ...client.CallOption) (*Response, error)
	// 回声，说话者可以听到自己的声音
	Echo2(ctx context.Context, in *Echo2Request, opts ...client.CallOption) (*Response, error)
	// 强插
	Intercept(ctx context.Context, in *InterceptRequest, opts ...client.CallOption) (*Response, error)
	// 协商转移
	Consult(ctx context.Context, in *ConsultRequest, opts ...client.CallOption) (*Response, error)
	// 设置通道变量
	SetVar(ctx context.Context, in *SetVarRequest, opts ...client.CallOption) (*Response, error)
	// 获取通道变量
	GetVar(ctx context.Context, in *GetVarRequest, opts ...client.CallOption) (*VarResponse, error)
	// 获取通道状态
	GetState_(ctx context.Context, in *GetStateRequest, opts ...client.CallOption) (*StateResponse, error)
	// 获取通道数据
	GetChannelData(ctx context.Context, in *GetChannelDataRequest, opts ...client.CallOption) (*ChannelDataResponse, error)
	//  读取DTMF按键
	ReadDTMF(ctx context.Context, in *DTMFRequest, opts ...client.CallOption) (*DTMFResponse, error)
	//  读取DTMF按键
	ReadDigits(ctx context.Context, in *DigitsRequest, opts ...client.CallOption) (*DigitsResponse, error)
	// 语音识别
	DetectSpeech(ctx context.Context, in *DetectRequest, opts ...client.CallOption) (*DetectResponse, error)
	// 停止语音识别
	StopDetectSpeech(ctx context.Context, in *StopDetectRequest, opts ...client.CallOption) (*Response, error)
	// 回铃音检测
	RingBackDetection(ctx context.Context, in *RingBackDetectionRequest, opts ...client.CallOption) (*Response, error)
	// 人脸识别
	DetectFace(ctx context.Context, in *DetectFaceRequest, opts ...client.CallOption) (*Response, error)
	// 发送DTMF
	SendDTMF(ctx context.Context, in *SendDTMFRequest, opts ...client.CallOption) (*Response, error)
	// 发送SIP INFO
	SendINFO(ctx context.Context, in *SendINFORequest, opts ...client.CallOption) (*Response, error)
	// 执行原生APP
	NativeApp(ctx context.Context, in *NativeRequest, opts ...client.CallOption) (*NativeResponse, error)
	// 执行原生API
	NativeAPI(ctx context.Context, in *NativeAPIRequest, opts ...client.CallOption) (*NativeResponse, error)
	// 执行原生JSAPI
	NativeJSAPI(ctx context.Context, in *XNativeJSRequest, opts ...client.CallOption) (*XNativeJSResponse, error)
	// 状态
	JStatus(ctx context.Context, in *JStatusRequest, opts ...client.CallOption) (*JStatusResponse, error)
	// 获取会议信息
	ConferenceInfo(ctx context.Context, in *ConferenceInfoRequest, opts ...client.CallOption) (*ConferenceInfoResponse, error)
	// 获取全部会议信息
	ConferenceList(ctx context.Context, in *ConferenceListRequest, opts ...client.CallOption) (*ConferenceListResponse, error)
	//呼叫中心FIFO队列（先入先出）
	FIFO(ctx context.Context, in *FIFORequest, opts ...client.CallOption) (*FIFOResponse, error)
	//呼叫中心Callcenter
	Callcenter(ctx context.Context, in *CallcenterRequest, opts ...client.CallOption) (*CallcenterResponse, error)
	//会议Conference
	Conference(ctx context.Context, in *ConferenceRequest, opts ...client.CallOption) (*ConferenceResponse, error)
	//会议AI
	AI(ctx context.Context, in *AIRequest, opts ...client.CallOption) (*AIResponse, error)
	//HttAPI
	HttAPI(ctx context.Context, in *HttAPIRequest, opts ...client.CallOption) (*HttAPIResponse, error)
	//Lua
	Lua(ctx context.Context, in *LuaRequest, opts ...client.CallOption) (*LuaResponse, error)
	// Node Register
	Register(ctx context.Context, in *Request, opts ...client.CallOption) (*Response, error)
}

type xNodeService struct {
	c    client.Client
	name string
}

func NewXNodeService(name string, c client.Client) XNodeService {
	return &xNodeService{
		c:    c,
		name: name,
	}
}

func (c *xNodeService) Dial(ctx context.Context, in *DialRequest, opts ...client.CallOption) (*DialResponse, error) {
	req := c.c.NewRequest(c.name, "XNode.Dial", in)
	out := new(DialResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xNodeService) Answer(ctx context.Context, in *AnswerRequest, opts ...client.CallOption) (*Response, error) {
	req := c.c.NewRequest(c.name, "XNode.Answer", in)
	out := new(Response)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ChannelEvent) Answer(in *AnswerRequest, opts ...client.CallOption) *Response {
	if c == nil {
		return &Response{
			Code:    500,
			Message: `Channel is nil`,
		}
	}
	if in.GetUuid() == `` {
		in.Uuid = c.GetUuid()
	}
	cOpts := client.CallOptions{}
	for _, opt := range opts {
		opt(&cOpts)
	}
	if len(cOpts.Address) == 0 {
		opts = append(opts, client.WithAddress(`cn.xswitch.node.`+c.GetNodeUuid()))
	}
	if cOpts.RequestTimeout == 0 {
		opts = append(opts, client.WithRequestTimeout(5*time.Second))
	}
	response, err := Service().Answer(context.TODO(), in, opts...)
	if err != nil {
		response = new(Response)
		e := errors.Parse(err.Error())
		response.Code = e.Code
		response.Message = e.Detail
	}
	return response
}

func (c *xNodeService) Accept(ctx context.Context, in *AcceptRequest, opts ...client.CallOption) (*Response, error) {
	req := c.c.NewRequest(c.name, "XNode.Accept", in)
	out := new(Response)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ChannelEvent) Accept(in *AcceptRequest, opts ...client.CallOption) *Response {
	if c == nil {
		return &Response{
			Code:    500,
			Message: `Channel is nil`,
		}
	}
	if in.GetUuid() == `` {
		in.Uuid = c.GetUuid()
	}
	cOpts := client.CallOptions{}
	for _, opt := range opts {
		opt(&cOpts)
	}
	if len(cOpts.Address) == 0 {
		opts = append(opts, client.WithAddress(`cn.xswitch.node.`+c.GetNodeUuid()))
	}
	if cOpts.RequestTimeout == 0 {
		opts = append(opts, client.WithRequestTimeout(5*time.Second))
	}
	response, err := Service().Accept(context.TODO(), in, opts...)
	if err != nil {
		response = new(Response)
		e := errors.Parse(err.Error())
		response.Code = e.Code
		response.Message = e.Detail
	}
	return response
}

func (c *xNodeService) Play(ctx context.Context, in *PlayRequest, opts ...client.CallOption) (*Response, error) {
	req := c.c.NewRequest(c.name, "XNode.Play", in)
	out := new(Response)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ChannelEvent) Play(in *PlayRequest, opts ...client.CallOption) *Response {
	if c == nil {
		return &Response{
			Code:    500,
			Message: `Channel is nil`,
		}
	}
	if in.GetUuid() == `` {
		in.Uuid = c.GetUuid()
	}
	cOpts := client.CallOptions{}
	for _, opt := range opts {
		opt(&cOpts)
	}
	if len(cOpts.Address) == 0 {
		opts = append(opts, client.WithAddress(`cn.xswitch.node.`+c.GetNodeUuid()))
	}
	if cOpts.RequestTimeout == 0 {
		opts = append(opts, client.WithRequestTimeout(180*time.Second))
	}
	response, err := Service().Play(context.TODO(), in, opts...)
	if err != nil {
		response = new(Response)
		e := errors.Parse(err.Error())
		response.Code = e.Code
		response.Message = e.Detail
	}
	return response
}

func (c *xNodeService) Stop(ctx context.Context, in *StopRequest, opts ...client.CallOption) (*Response, error) {
	req := c.c.NewRequest(c.name, "XNode.Stop", in)
	out := new(Response)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ChannelEvent) Stop(in *StopRequest, opts ...client.CallOption) *Response {
	if c == nil {
		return &Response{
			Code:    500,
			Message: `Channel is nil`,
		}
	}
	if in.GetUuid() == `` {
		in.Uuid = c.GetUuid()
	}
	cOpts := client.CallOptions{}
	for _, opt := range opts {
		opt(&cOpts)
	}
	if len(cOpts.Address) == 0 {
		opts = append(opts, client.WithAddress(`cn.xswitch.node.`+c.GetNodeUuid()))
	}
	if cOpts.RequestTimeout == 0 {
		opts = append(opts, client.WithRequestTimeout(5*time.Second))
	}
	response, err := Service().Stop(context.TODO(), in, opts...)
	if err != nil {
		response = new(Response)
		e := errors.Parse(err.Error())
		response.Code = e.Code
		response.Message = e.Detail
	}
	return response
}

func (c *xNodeService) Broadcast(ctx context.Context, in *BroadcastRequest, opts ...client.CallOption) (*Response, error) {
	req := c.c.NewRequest(c.name, "XNode.Broadcast", in)
	out := new(Response)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ChannelEvent) Broadcast(in *BroadcastRequest, opts ...client.CallOption) *Response {
	if c == nil {
		return &Response{
			Code:    500,
			Message: `Channel is nil`,
		}
	}
	if in.GetUuid() == `` {
		in.Uuid = c.GetUuid()
	}
	cOpts := client.CallOptions{}
	for _, opt := range opts {
		opt(&cOpts)
	}
	if len(cOpts.Address) == 0 {
		opts = append(opts, client.WithAddress(`cn.xswitch.node.`+c.GetNodeUuid()))
	}
	if cOpts.RequestTimeout == 0 {
		opts = append(opts, client.WithRequestTimeout(5*time.Second))
	}
	response, err := Service().Broadcast(context.TODO(), in, opts...)
	if err != nil {
		response = new(Response)
		e := errors.Parse(err.Error())
		response.Code = e.Code
		response.Message = e.Detail
	}
	return response
}

func (c *xNodeService) Mute(ctx context.Context, in *MuteRequest, opts ...client.CallOption) (*Response, error) {
	req := c.c.NewRequest(c.name, "XNode.Mute", in)
	out := new(Response)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ChannelEvent) Mute(in *MuteRequest, opts ...client.CallOption) *Response {
	if c == nil {
		return &Response{
			Code:    500,
			Message: `Channel is nil`,
		}
	}
	if in.GetUuid() == `` {
		in.Uuid = c.GetUuid()
	}
	cOpts := client.CallOptions{}
	for _, opt := range opts {
		opt(&cOpts)
	}
	if len(cOpts.Address) == 0 {
		opts = append(opts, client.WithAddress(`cn.xswitch.node.`+c.GetNodeUuid()))
	}
	if cOpts.RequestTimeout == 0 {
		opts = append(opts, client.WithRequestTimeout(5*time.Second))
	}
	response, err := Service().Mute(context.TODO(), in, opts...)
	if err != nil {
		response = new(Response)
		e := errors.Parse(err.Error())
		response.Code = e.Code
		response.Message = e.Detail
	}
	return response
}

func (c *xNodeService) Record(ctx context.Context, in *RecordRequest, opts ...client.CallOption) (*RecordResponse, error) {
	req := c.c.NewRequest(c.name, "XNode.Record", in)
	out := new(RecordResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ChannelEvent) Record(in *RecordRequest, opts ...client.CallOption) *RecordResponse {
	if c == nil {
		return &RecordResponse{
			Code:    500,
			Message: `Channel is nil`,
		}
	}
	if in.GetUuid() == `` {
		in.Uuid = c.GetUuid()
	}
	cOpts := client.CallOptions{}
	for _, opt := range opts {
		opt(&cOpts)
	}
	if len(cOpts.Address) == 0 {
		opts = append(opts, client.WithAddress(`cn.xswitch.node.`+c.GetNodeUuid()))
	}
	if cOpts.RequestTimeout == 0 {
		opts = append(opts, client.WithRequestTimeout(5*time.Second))
	}
	response, err := Service().Record(context.TODO(), in, opts...)
	if err != nil {
		response = new(RecordResponse)
		e := errors.Parse(err.Error())
		response.Code = e.Code
		response.Message = e.Detail
	}
	return response
}

func (c *xNodeService) Hangup(ctx context.Context, in *HangupRequest, opts ...client.CallOption) (*Response, error) {
	req := c.c.NewRequest(c.name, "XNode.Hangup", in)
	out := new(Response)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ChannelEvent) Hangup(in *HangupRequest, opts ...client.CallOption) *Response {
	if c == nil {
		return &Response{
			Code:    500,
			Message: `Channel is nil`,
		}
	}
	if in.GetUuid() == `` {
		in.Uuid = c.GetUuid()
	}
	cOpts := client.CallOptions{}
	for _, opt := range opts {
		opt(&cOpts)
	}
	if len(cOpts.Address) == 0 {
		opts = append(opts, client.WithAddress(`cn.xswitch.node.`+c.GetNodeUuid()))
	}
	if cOpts.RequestTimeout == 0 {
		opts = append(opts, client.WithRequestTimeout(5*time.Second))
	}
	response, err := Service().Hangup(context.TODO(), in, opts...)
	if err != nil {
		response = new(Response)
		e := errors.Parse(err.Error())
		response.Code = e.Code
		response.Message = e.Detail
	}
	return response
}

func (c *xNodeService) Bridge(ctx context.Context, in *BridgeRequest, opts ...client.CallOption) (*Response, error) {
	req := c.c.NewRequest(c.name, "XNode.Bridge", in)
	out := new(Response)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ChannelEvent) Bridge(in *BridgeRequest, opts ...client.CallOption) *Response {
	if c == nil {
		return &Response{
			Code:    500,
			Message: `Channel is nil`,
		}
	}
	if in.GetUuid() == `` {
		in.Uuid = c.GetUuid()
	}
	cOpts := client.CallOptions{}
	for _, opt := range opts {
		opt(&cOpts)
	}
	if len(cOpts.Address) == 0 {
		opts = append(opts, client.WithAddress(`cn.xswitch.node.`+c.GetNodeUuid()))
	}
	if cOpts.RequestTimeout == 0 {
		opts = append(opts, client.WithRequestTimeout(3600*time.Second))
	}
	response, err := Service().Bridge(context.TODO(), in, opts...)
	if err != nil {
		response = new(Response)
		e := errors.Parse(err.Error())
		response.Code = e.Code
		response.Message = e.Detail
	}
	return response
}

func (c *xNodeService) ChannelBridge(ctx context.Context, in *ChannelBridgeRequest, opts ...client.CallOption) (*Response, error) {
	req := c.c.NewRequest(c.name, "XNode.ChannelBridge", in)
	out := new(Response)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ChannelEvent) ChannelBridge(in *ChannelBridgeRequest, opts ...client.CallOption) *Response {
	if c == nil {
		return &Response{
			Code:    500,
			Message: `Channel is nil`,
		}
	}
	if in.GetUuid() == `` {
		in.Uuid = c.GetUuid()
	}
	cOpts := client.CallOptions{}
	for _, opt := range opts {
		opt(&cOpts)
	}
	if len(cOpts.Address) == 0 {
		opts = append(opts, client.WithAddress(`cn.xswitch.node.`+c.GetNodeUuid()))
	}
	if cOpts.RequestTimeout == 0 {
		opts = append(opts, client.WithRequestTimeout(5*time.Second))
	}
	response, err := Service().ChannelBridge(context.TODO(), in, opts...)
	if err != nil {
		response = new(Response)
		e := errors.Parse(err.Error())
		response.Code = e.Code
		response.Message = e.Detail
	}
	return response
}

func (c *xNodeService) UnBridge(ctx context.Context, in *Request, opts ...client.CallOption) (*Response, error) {
	req := c.c.NewRequest(c.name, "XNode.UnBridge", in)
	out := new(Response)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xNodeService) UnBridge2(ctx context.Context, in *Request, opts ...client.CallOption) (*Response, error) {
	req := c.c.NewRequest(c.name, "XNode.UnBridge2", in)
	out := new(Response)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xNodeService) Hold(ctx context.Context, in *HoldRequest, opts ...client.CallOption) (*Response, error) {
	req := c.c.NewRequest(c.name, "XNode.Hold", in)
	out := new(Response)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ChannelEvent) Hold(in *HoldRequest, opts ...client.CallOption) *Response {
	if c == nil {
		return &Response{
			Code:    500,
			Message: `Channel is nil`,
		}
	}
	if in.GetUuid() == `` {
		in.Uuid = c.GetUuid()
	}
	cOpts := client.CallOptions{}
	for _, opt := range opts {
		opt(&cOpts)
	}
	if len(cOpts.Address) == 0 {
		opts = append(opts, client.WithAddress(`cn.xswitch.node.`+c.GetNodeUuid()))
	}
	if cOpts.RequestTimeout == 0 {
		opts = append(opts, client.WithRequestTimeout(5*time.Second))
	}
	response, err := Service().Hold(context.TODO(), in, opts...)
	if err != nil {
		response = new(Response)
		e := errors.Parse(err.Error())
		response.Code = e.Code
		response.Message = e.Detail
	}
	return response
}

func (c *xNodeService) Transfer(ctx context.Context, in *TransferRequest, opts ...client.CallOption) (*Response, error) {
	req := c.c.NewRequest(c.name, "XNode.Transfer", in)
	out := new(Response)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ChannelEvent) Transfer(in *TransferRequest, opts ...client.CallOption) *Response {
	if c == nil {
		return &Response{
			Code:    500,
			Message: `Channel is nil`,
		}
	}
	if in.GetUuid() == `` {
		in.Uuid = c.GetUuid()
	}
	cOpts := client.CallOptions{}
	for _, opt := range opts {
		opt(&cOpts)
	}
	if len(cOpts.Address) == 0 {
		opts = append(opts, client.WithAddress(`cn.xswitch.node.`+c.GetNodeUuid()))
	}
	if cOpts.RequestTimeout == 0 {
		opts = append(opts, client.WithRequestTimeout(5*time.Second))
	}
	response, err := Service().Transfer(context.TODO(), in, opts...)
	if err != nil {
		response = new(Response)
		e := errors.Parse(err.Error())
		response.Code = e.Code
		response.Message = e.Detail
	}
	return response
}

func (c *xNodeService) ThreeWay(ctx context.Context, in *ThreeWayRequest, opts ...client.CallOption) (*Response, error) {
	req := c.c.NewRequest(c.name, "XNode.ThreeWay", in)
	out := new(Response)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ChannelEvent) ThreeWay(in *ThreeWayRequest, opts ...client.CallOption) *Response {
	if c == nil {
		return &Response{
			Code:    500,
			Message: `Channel is nil`,
		}
	}
	if in.GetUuid() == `` {
		in.Uuid = c.GetUuid()
	}
	cOpts := client.CallOptions{}
	for _, opt := range opts {
		opt(&cOpts)
	}
	if len(cOpts.Address) == 0 {
		opts = append(opts, client.WithAddress(`cn.xswitch.node.`+c.GetNodeUuid()))
	}
	if cOpts.RequestTimeout == 0 {
		opts = append(opts, client.WithRequestTimeout(3600*time.Second))
	}
	response, err := Service().ThreeWay(context.TODO(), in, opts...)
	if err != nil {
		response = new(Response)
		e := errors.Parse(err.Error())
		response.Code = e.Code
		response.Message = e.Detail
	}
	return response
}

func (c *xNodeService) Echo2(ctx context.Context, in *Echo2Request, opts ...client.CallOption) (*Response, error) {
	req := c.c.NewRequest(c.name, "XNode.Echo2", in)
	out := new(Response)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ChannelEvent) Echo2(in *Echo2Request, opts ...client.CallOption) *Response {
	if c == nil {
		return &Response{
			Code:    500,
			Message: `Channel is nil`,
		}
	}
	if in.GetUuid() == `` {
		in.Uuid = c.GetUuid()
	}
	cOpts := client.CallOptions{}
	for _, opt := range opts {
		opt(&cOpts)
	}
	if len(cOpts.Address) == 0 {
		opts = append(opts, client.WithAddress(`cn.xswitch.node.`+c.GetNodeUuid()))
	}
	if cOpts.RequestTimeout == 0 {
		opts = append(opts, client.WithRequestTimeout(3600*time.Second))
	}
	response, err := Service().Echo2(context.TODO(), in, opts...)
	if err != nil {
		response = new(Response)
		e := errors.Parse(err.Error())
		response.Code = e.Code
		response.Message = e.Detail
	}
	return response
}

func (c *xNodeService) Intercept(ctx context.Context, in *InterceptRequest, opts ...client.CallOption) (*Response, error) {
	req := c.c.NewRequest(c.name, "XNode.Intercept", in)
	out := new(Response)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ChannelEvent) Intercept(in *InterceptRequest, opts ...client.CallOption) *Response {
	if c == nil {
		return &Response{
			Code:    500,
			Message: `Channel is nil`,
		}
	}
	if in.GetUuid() == `` {
		in.Uuid = c.GetUuid()
	}
	cOpts := client.CallOptions{}
	for _, opt := range opts {
		opt(&cOpts)
	}
	if len(cOpts.Address) == 0 {
		opts = append(opts, client.WithAddress(`cn.xswitch.node.`+c.GetNodeUuid()))
	}
	if cOpts.RequestTimeout == 0 {
		opts = append(opts, client.WithRequestTimeout(3600*time.Second))
	}
	response, err := Service().Intercept(context.TODO(), in, opts...)
	if err != nil {
		response = new(Response)
		e := errors.Parse(err.Error())
		response.Code = e.Code
		response.Message = e.Detail
	}
	return response
}

func (c *xNodeService) Consult(ctx context.Context, in *ConsultRequest, opts ...client.CallOption) (*Response, error) {
	req := c.c.NewRequest(c.name, "XNode.Consult", in)
	out := new(Response)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ChannelEvent) Consult(in *ConsultRequest, opts ...client.CallOption) *Response {
	if c == nil {
		return &Response{
			Code:    500,
			Message: `Channel is nil`,
		}
	}
	if in.GetUuid() == `` {
		in.Uuid = c.GetUuid()
	}
	cOpts := client.CallOptions{}
	for _, opt := range opts {
		opt(&cOpts)
	}
	if len(cOpts.Address) == 0 {
		opts = append(opts, client.WithAddress(`cn.xswitch.node.`+c.GetNodeUuid()))
	}
	if cOpts.RequestTimeout == 0 {
		opts = append(opts, client.WithRequestTimeout(3600*time.Second))
	}
	response, err := Service().Consult(context.TODO(), in, opts...)
	if err != nil {
		response = new(Response)
		e := errors.Parse(err.Error())
		response.Code = e.Code
		response.Message = e.Detail
	}
	return response
}

func (c *xNodeService) SetVar(ctx context.Context, in *SetVarRequest, opts ...client.CallOption) (*Response, error) {
	req := c.c.NewRequest(c.name, "XNode.SetVar", in)
	out := new(Response)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xNodeService) GetVar(ctx context.Context, in *GetVarRequest, opts ...client.CallOption) (*VarResponse, error) {
	req := c.c.NewRequest(c.name, "XNode.GetVar", in)
	out := new(VarResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xNodeService) GetState_(ctx context.Context, in *GetStateRequest, opts ...client.CallOption) (*StateResponse, error) {
	req := c.c.NewRequest(c.name, "XNode.GetState", in)
	out := new(StateResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ChannelEvent) GetState_(in *GetStateRequest, opts ...client.CallOption) *StateResponse {
	if c == nil {
		return &StateResponse{
			Code:    500,
			Message: `Channel is nil`,
		}
	}
	if in.GetUuid() == `` {
		in.Uuid = c.GetUuid()
	}
	cOpts := client.CallOptions{}
	for _, opt := range opts {
		opt(&cOpts)
	}
	if len(cOpts.Address) == 0 {
		opts = append(opts, client.WithAddress(`cn.xswitch.node.`+c.GetNodeUuid()))
	}
	if cOpts.RequestTimeout == 0 {
		opts = append(opts, client.WithRequestTimeout(5*time.Second))
	}
	response, err := Service().GetState_(context.TODO(), in, opts...)
	if err != nil {
		response = new(StateResponse)
		e := errors.Parse(err.Error())
		response.Code = e.Code
		response.Message = e.Detail
	}
	return response
}

func (c *xNodeService) GetChannelData(ctx context.Context, in *GetChannelDataRequest, opts ...client.CallOption) (*ChannelDataResponse, error) {
	req := c.c.NewRequest(c.name, "XNode.GetChannelData", in)
	out := new(ChannelDataResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ChannelEvent) GetChannelData(in *GetChannelDataRequest, opts ...client.CallOption) *ChannelDataResponse {
	if c == nil {
		return &ChannelDataResponse{
			Code:    500,
			Message: `Channel is nil`,
		}
	}
	if in.GetUuid() == `` {
		in.Uuid = c.GetUuid()
	}
	cOpts := client.CallOptions{}
	for _, opt := range opts {
		opt(&cOpts)
	}
	if len(cOpts.Address) == 0 {
		opts = append(opts, client.WithAddress(`cn.xswitch.node.`+c.GetNodeUuid()))
	}
	if cOpts.RequestTimeout == 0 {
		opts = append(opts, client.WithRequestTimeout(5*time.Second))
	}
	response, err := Service().GetChannelData(context.TODO(), in, opts...)
	if err != nil {
		response = new(ChannelDataResponse)
		e := errors.Parse(err.Error())
		response.Code = e.Code
		response.Message = e.Detail
	}
	return response
}

func (c *xNodeService) ReadDTMF(ctx context.Context, in *DTMFRequest, opts ...client.CallOption) (*DTMFResponse, error) {
	req := c.c.NewRequest(c.name, "XNode.ReadDTMF", in)
	out := new(DTMFResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ChannelEvent) ReadDTMF(in *DTMFRequest, opts ...client.CallOption) *DTMFResponse {
	if c == nil {
		return &DTMFResponse{
			Code:    500,
			Message: `Channel is nil`,
		}
	}
	if in.GetUuid() == `` {
		in.Uuid = c.GetUuid()
	}
	cOpts := client.CallOptions{}
	for _, opt := range opts {
		opt(&cOpts)
	}
	if len(cOpts.Address) == 0 {
		opts = append(opts, client.WithAddress(`cn.xswitch.node.`+c.GetNodeUuid()))
	}
	if cOpts.RequestTimeout == 0 {
		opts = append(opts, client.WithRequestTimeout(60*time.Second))
	}
	response, err := Service().ReadDTMF(context.TODO(), in, opts...)
	if err != nil {
		response = new(DTMFResponse)
		e := errors.Parse(err.Error())
		response.Code = e.Code
		response.Message = e.Detail
	}
	return response
}

func (c *xNodeService) ReadDigits(ctx context.Context, in *DigitsRequest, opts ...client.CallOption) (*DigitsResponse, error) {
	req := c.c.NewRequest(c.name, "XNode.ReadDigits", in)
	out := new(DigitsResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ChannelEvent) ReadDigits(in *DigitsRequest, opts ...client.CallOption) *DigitsResponse {
	if c == nil {
		return &DigitsResponse{
			Code:    500,
			Message: `Channel is nil`,
		}
	}
	if in.GetUuid() == `` {
		in.Uuid = c.GetUuid()
	}
	cOpts := client.CallOptions{}
	for _, opt := range opts {
		opt(&cOpts)
	}
	if len(cOpts.Address) == 0 {
		opts = append(opts, client.WithAddress(`cn.xswitch.node.`+c.GetNodeUuid()))
	}
	if cOpts.RequestTimeout == 0 {
		opts = append(opts, client.WithRequestTimeout(60*time.Second))
	}
	response, err := Service().ReadDigits(context.TODO(), in, opts...)
	if err != nil {
		response = new(DigitsResponse)
		e := errors.Parse(err.Error())
		response.Code = e.Code
		response.Message = e.Detail
	}
	return response
}

func (c *xNodeService) DetectSpeech(ctx context.Context, in *DetectRequest, opts ...client.CallOption) (*DetectResponse, error) {
	req := c.c.NewRequest(c.name, "XNode.DetectSpeech", in)
	out := new(DetectResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ChannelEvent) DetectSpeech(in *DetectRequest, opts ...client.CallOption) *DetectResponse {
	if c == nil {
		return &DetectResponse{
			Code:    500,
			Message: `Channel is nil`,
		}
	}
	if in.GetUuid() == `` {
		in.Uuid = c.GetUuid()
	}
	cOpts := client.CallOptions{}
	for _, opt := range opts {
		opt(&cOpts)
	}
	if len(cOpts.Address) == 0 {
		opts = append(opts, client.WithAddress(`cn.xswitch.node.`+c.GetNodeUuid()))
	}
	if cOpts.RequestTimeout == 0 {
		opts = append(opts, client.WithRequestTimeout(180*time.Second))
	}
	response, err := Service().DetectSpeech(context.TODO(), in, opts...)
	if err != nil {
		response = new(DetectResponse)
		e := errors.Parse(err.Error())
		response.Code = e.Code
		response.Message = e.Detail
	}
	return response
}

func (c *xNodeService) StopDetectSpeech(ctx context.Context, in *StopDetectRequest, opts ...client.CallOption) (*Response, error) {
	req := c.c.NewRequest(c.name, "XNode.StopDetectSpeech", in)
	out := new(Response)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ChannelEvent) StopDetectSpeech(in *StopDetectRequest, opts ...client.CallOption) *Response {
	if c == nil {
		return &Response{
			Code:    500,
			Message: `Channel is nil`,
		}
	}
	if in.GetUuid() == `` {
		in.Uuid = c.GetUuid()
	}
	cOpts := client.CallOptions{}
	for _, opt := range opts {
		opt(&cOpts)
	}
	if len(cOpts.Address) == 0 {
		opts = append(opts, client.WithAddress(`cn.xswitch.node.`+c.GetNodeUuid()))
	}
	if cOpts.RequestTimeout == 0 {
		opts = append(opts, client.WithRequestTimeout(5*time.Second))
	}
	response, err := Service().StopDetectSpeech(context.TODO(), in, opts...)
	if err != nil {
		response = new(Response)
		e := errors.Parse(err.Error())
		response.Code = e.Code
		response.Message = e.Detail
	}
	return response
}

func (c *xNodeService) RingBackDetection(ctx context.Context, in *RingBackDetectionRequest, opts ...client.CallOption) (*Response, error) {
	req := c.c.NewRequest(c.name, "XNode.RingBackDetection", in)
	out := new(Response)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ChannelEvent) RingBackDetection(in *RingBackDetectionRequest, opts ...client.CallOption) *Response {
	if c == nil {
		return &Response{
			Code:    500,
			Message: `Channel is nil`,
		}
	}
	if in.GetUuid() == `` {
		in.Uuid = c.GetUuid()
	}
	cOpts := client.CallOptions{}
	for _, opt := range opts {
		opt(&cOpts)
	}
	if len(cOpts.Address) == 0 {
		opts = append(opts, client.WithAddress(`cn.xswitch.node.`+c.GetNodeUuid()))
	}
	if cOpts.RequestTimeout == 0 {
		opts = append(opts, client.WithRequestTimeout(60*time.Second))
	}
	response, err := Service().RingBackDetection(context.TODO(), in, opts...)
	if err != nil {
		response = new(Response)
		e := errors.Parse(err.Error())
		response.Code = e.Code
		response.Message = e.Detail
	}
	return response
}

func (c *xNodeService) DetectFace(ctx context.Context, in *DetectFaceRequest, opts ...client.CallOption) (*Response, error) {
	req := c.c.NewRequest(c.name, "XNode.DetectFace", in)
	out := new(Response)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ChannelEvent) DetectFace(in *DetectFaceRequest, opts ...client.CallOption) *Response {
	if c == nil {
		return &Response{
			Code:    500,
			Message: `Channel is nil`,
		}
	}
	if in.GetUuid() == `` {
		in.Uuid = c.GetUuid()
	}
	cOpts := client.CallOptions{}
	for _, opt := range opts {
		opt(&cOpts)
	}
	if len(cOpts.Address) == 0 {
		opts = append(opts, client.WithAddress(`cn.xswitch.node.`+c.GetNodeUuid()))
	}
	if cOpts.RequestTimeout == 0 {
		opts = append(opts, client.WithRequestTimeout(180*time.Second))
	}
	response, err := Service().DetectFace(context.TODO(), in, opts...)
	if err != nil {
		response = new(Response)
		e := errors.Parse(err.Error())
		response.Code = e.Code
		response.Message = e.Detail
	}
	return response
}

func (c *xNodeService) SendDTMF(ctx context.Context, in *SendDTMFRequest, opts ...client.CallOption) (*Response, error) {
	req := c.c.NewRequest(c.name, "XNode.SendDTMF", in)
	out := new(Response)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ChannelEvent) SendDTMF(in *SendDTMFRequest, opts ...client.CallOption) *Response {
	if c == nil {
		return &Response{
			Code:    500,
			Message: `Channel is nil`,
		}
	}
	if in.GetUuid() == `` {
		in.Uuid = c.GetUuid()
	}
	cOpts := client.CallOptions{}
	for _, opt := range opts {
		opt(&cOpts)
	}
	if len(cOpts.Address) == 0 {
		opts = append(opts, client.WithAddress(`cn.xswitch.node.`+c.GetNodeUuid()))
	}
	if cOpts.RequestTimeout == 0 {
		opts = append(opts, client.WithRequestTimeout(5*time.Second))
	}
	response, err := Service().SendDTMF(context.TODO(), in, opts...)
	if err != nil {
		response = new(Response)
		e := errors.Parse(err.Error())
		response.Code = e.Code
		response.Message = e.Detail
	}
	return response
}

func (c *xNodeService) SendINFO(ctx context.Context, in *SendINFORequest, opts ...client.CallOption) (*Response, error) {
	req := c.c.NewRequest(c.name, "XNode.SendINFO", in)
	out := new(Response)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xNodeService) NativeApp(ctx context.Context, in *NativeRequest, opts ...client.CallOption) (*NativeResponse, error) {
	req := c.c.NewRequest(c.name, "XNode.NativeApp", in)
	out := new(NativeResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ChannelEvent) NativeApp(in *NativeRequest, opts ...client.CallOption) *NativeResponse {
	if c == nil {
		return &NativeResponse{
			Code:    500,
			Message: `Channel is nil`,
		}
	}
	if in.GetUuid() == `` {
		in.Uuid = c.GetUuid()
	}
	cOpts := client.CallOptions{}
	for _, opt := range opts {
		opt(&cOpts)
	}
	if len(cOpts.Address) == 0 {
		opts = append(opts, client.WithAddress(`cn.xswitch.node.`+c.GetNodeUuid()))
	}
	if cOpts.RequestTimeout == 0 {
		opts = append(opts, client.WithRequestTimeout(5*time.Second))
	}
	response, err := Service().NativeApp(context.TODO(), in, opts...)
	if err != nil {
		response = new(NativeResponse)
		e := errors.Parse(err.Error())
		response.Code = e.Code
		response.Message = e.Detail
	}
	return response
}

func (c *xNodeService) NativeAPI(ctx context.Context, in *NativeAPIRequest, opts ...client.CallOption) (*NativeResponse, error) {
	req := c.c.NewRequest(c.name, "XNode.NativeAPI", in)
	out := new(NativeResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xNodeService) NativeJSAPI(ctx context.Context, in *XNativeJSRequest, opts ...client.CallOption) (*XNativeJSResponse, error) {
	req := c.c.NewRequest(c.name, "XNode.NativeJSAPI", in)
	out := new(XNativeJSResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xNodeService) JStatus(ctx context.Context, in *JStatusRequest, opts ...client.CallOption) (*JStatusResponse, error) {
	req := c.c.NewRequest(c.name, "XNode.JStatus", in)
	out := new(JStatusResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xNodeService) ConferenceInfo(ctx context.Context, in *ConferenceInfoRequest, opts ...client.CallOption) (*ConferenceInfoResponse, error) {
	req := c.c.NewRequest(c.name, "XNode.ConferenceInfo", in)
	out := new(ConferenceInfoResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xNodeService) ConferenceList(ctx context.Context, in *ConferenceListRequest, opts ...client.CallOption) (*ConferenceListResponse, error) {
	req := c.c.NewRequest(c.name, "XNode.ConferenceList", in)
	out := new(ConferenceListResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xNodeService) FIFO(ctx context.Context, in *FIFORequest, opts ...client.CallOption) (*FIFOResponse, error) {
	req := c.c.NewRequest(c.name, "XNode.FIFO", in)
	out := new(FIFOResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ChannelEvent) FIFO(in *FIFORequest, opts ...client.CallOption) *FIFOResponse {
	if c == nil {
		return &FIFOResponse{
			Code:    500,
			Message: `Channel is nil`,
		}
	}
	if in.GetUuid() == `` {
		in.Uuid = c.GetUuid()
	}
	cOpts := client.CallOptions{}
	for _, opt := range opts {
		opt(&cOpts)
	}
	if len(cOpts.Address) == 0 {
		opts = append(opts, client.WithAddress(`cn.xswitch.node.`+c.GetNodeUuid()))
	}
	if cOpts.RequestTimeout == 0 {
		opts = append(opts, client.WithRequestTimeout(1200*time.Second))
	}
	response, err := Service().FIFO(context.TODO(), in, opts...)
	if err != nil {
		response = new(FIFOResponse)
		e := errors.Parse(err.Error())
		response.Code = e.Code
		response.Message = e.Detail
	}
	return response
}

func (c *xNodeService) Callcenter(ctx context.Context, in *CallcenterRequest, opts ...client.CallOption) (*CallcenterResponse, error) {
	req := c.c.NewRequest(c.name, "XNode.Callcenter", in)
	out := new(CallcenterResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ChannelEvent) Callcenter(in *CallcenterRequest, opts ...client.CallOption) *CallcenterResponse {
	if c == nil {
		return &CallcenterResponse{
			Code:    500,
			Message: `Channel is nil`,
		}
	}
	if in.GetUuid() == `` {
		in.Uuid = c.GetUuid()
	}
	cOpts := client.CallOptions{}
	for _, opt := range opts {
		opt(&cOpts)
	}
	if len(cOpts.Address) == 0 {
		opts = append(opts, client.WithAddress(`cn.xswitch.node.`+c.GetNodeUuid()))
	}
	if cOpts.RequestTimeout == 0 {
		opts = append(opts, client.WithRequestTimeout(1200*time.Second))
	}
	response, err := Service().Callcenter(context.TODO(), in, opts...)
	if err != nil {
		response = new(CallcenterResponse)
		e := errors.Parse(err.Error())
		response.Code = e.Code
		response.Message = e.Detail
	}
	return response
}

func (c *xNodeService) Conference(ctx context.Context, in *ConferenceRequest, opts ...client.CallOption) (*ConferenceResponse, error) {
	req := c.c.NewRequest(c.name, "XNode.Conference", in)
	out := new(ConferenceResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ChannelEvent) Conference(in *ConferenceRequest, opts ...client.CallOption) *ConferenceResponse {
	if c == nil {
		return &ConferenceResponse{
			Code:    500,
			Message: `Channel is nil`,
		}
	}
	if in.GetUuid() == `` {
		in.Uuid = c.GetUuid()
	}
	cOpts := client.CallOptions{}
	for _, opt := range opts {
		opt(&cOpts)
	}
	if len(cOpts.Address) == 0 {
		opts = append(opts, client.WithAddress(`cn.xswitch.node.`+c.GetNodeUuid()))
	}
	if cOpts.RequestTimeout == 0 {
		opts = append(opts, client.WithRequestTimeout(3600*time.Second))
	}
	response, err := Service().Conference(context.TODO(), in, opts...)
	if err != nil {
		response = new(ConferenceResponse)
		e := errors.Parse(err.Error())
		response.Code = e.Code
		response.Message = e.Detail
	}
	return response
}

func (c *xNodeService) AI(ctx context.Context, in *AIRequest, opts ...client.CallOption) (*AIResponse, error) {
	req := c.c.NewRequest(c.name, "XNode.AI", in)
	out := new(AIResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ChannelEvent) AI(in *AIRequest, opts ...client.CallOption) *AIResponse {
	if c == nil {
		return &AIResponse{
			Code:    500,
			Message: `Channel is nil`,
		}
	}
	if in.GetUuid() == `` {
		in.Uuid = c.GetUuid()
	}
	cOpts := client.CallOptions{}
	for _, opt := range opts {
		opt(&cOpts)
	}
	if len(cOpts.Address) == 0 {
		opts = append(opts, client.WithAddress(`cn.xswitch.node.`+c.GetNodeUuid()))
	}
	if cOpts.RequestTimeout == 0 {
		opts = append(opts, client.WithRequestTimeout(3600*time.Second))
	}
	response, err := Service().AI(context.TODO(), in, opts...)
	if err != nil {
		response = new(AIResponse)
		e := errors.Parse(err.Error())
		response.Code = e.Code
		response.Message = e.Detail
	}
	return response
}

func (c *xNodeService) HttAPI(ctx context.Context, in *HttAPIRequest, opts ...client.CallOption) (*HttAPIResponse, error) {
	req := c.c.NewRequest(c.name, "XNode.HttAPI", in)
	out := new(HttAPIResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ChannelEvent) HttAPI(in *HttAPIRequest, opts ...client.CallOption) *HttAPIResponse {
	if c == nil {
		return &HttAPIResponse{
			Code:    500,
			Message: `Channel is nil`,
		}
	}
	if in.GetUuid() == `` {
		in.Uuid = c.GetUuid()
	}
	cOpts := client.CallOptions{}
	for _, opt := range opts {
		opt(&cOpts)
	}
	if len(cOpts.Address) == 0 {
		opts = append(opts, client.WithAddress(`cn.xswitch.node.`+c.GetNodeUuid()))
	}
	if cOpts.RequestTimeout == 0 {
		opts = append(opts, client.WithRequestTimeout(3600*time.Second))
	}
	response, err := Service().HttAPI(context.TODO(), in, opts...)
	if err != nil {
		response = new(HttAPIResponse)
		e := errors.Parse(err.Error())
		response.Code = e.Code
		response.Message = e.Detail
	}
	return response
}

func (c *xNodeService) Lua(ctx context.Context, in *LuaRequest, opts ...client.CallOption) (*LuaResponse, error) {
	req := c.c.NewRequest(c.name, "XNode.Lua", in)
	out := new(LuaResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ChannelEvent) Lua(in *LuaRequest, opts ...client.CallOption) *LuaResponse {
	if c == nil {
		return &LuaResponse{
			Code:    500,
			Message: `Channel is nil`,
		}
	}
	if in.GetUuid() == `` {
		in.Uuid = c.GetUuid()
	}
	cOpts := client.CallOptions{}
	for _, opt := range opts {
		opt(&cOpts)
	}
	if len(cOpts.Address) == 0 {
		opts = append(opts, client.WithAddress(`cn.xswitch.node.`+c.GetNodeUuid()))
	}
	if cOpts.RequestTimeout == 0 {
		opts = append(opts, client.WithRequestTimeout(3600*time.Second))
	}
	response, err := Service().Lua(context.TODO(), in, opts...)
	if err != nil {
		response = new(LuaResponse)
		e := errors.Parse(err.Error())
		response.Code = e.Code
		response.Message = e.Detail
	}
	return response
}

func (c *xNodeService) Register(ctx context.Context, in *Request, opts ...client.CallOption) (*Response, error) {
	req := c.c.NewRequest(c.name, "XNode.Register", in)
	out := new(Response)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for XNode service

type XNodeHandler interface {
	// 外呼
	Dial(context.Context, *DialRequest, *DialResponse) error
	// 应答,
	Answer(context.Context, *AnswerRequest, *Response) error
	// 接管呼叫，被接管的呼叫将会在10s后挂断
	Accept(context.Context, *AcceptRequest, *Response) error
	// 播放一个文件或TTS
	Play(context.Context, *PlayRequest, *Response) error
	// 停止当前正在执行的API
	Stop(context.Context, *StopRequest, *Response) error
	// 广播
	Broadcast(context.Context, *BroadcastRequest, *Response) error
	// 设置静音
	Mute(context.Context, *MuteRequest, *Response) error
	// 录音
	Record(context.Context, *RecordRequest, *RecordResponse) error
	// 挂断当前UUID
	Hangup(context.Context, *HangupRequest, *Response) error
	// 在把当前呼叫桥接（发起）另一个呼叫
	Bridge(context.Context, *BridgeRequest, *Response) error
	// 桥接两个呼叫
	ChannelBridge(context.Context, *ChannelBridgeRequest, *Response) error
	// 将桥接的呼叫分开
	UnBridge(context.Context, *Request, *Response) error
	// 将桥接的呼叫分开
	UnBridge2(context.Context, *Request, *Response) error
	// 呼叫保持/取消保持
	Hold(context.Context, *HoldRequest, *Response) error
	// 转移（待定）
	Transfer(context.Context, *TransferRequest, *Response) error
	// 三方通话
	ThreeWay(context.Context, *ThreeWayRequest, *Response) error
	// 回声，说话者可以听到自己的声音
	Echo2(context.Context, *Echo2Request, *Response) error
	// 强插
	Intercept(context.Context, *InterceptRequest, *Response) error
	// 协商转移
	Consult(context.Context, *ConsultRequest, *Response) error
	// 设置通道变量
	SetVar(context.Context, *SetVarRequest, *Response) error
	// 获取通道变量
	GetVar(context.Context, *GetVarRequest, *VarResponse) error
	// 获取通道状态
	GetState_(context.Context, *GetStateRequest, *StateResponse) error
	// 获取通道数据
	GetChannelData(context.Context, *GetChannelDataRequest, *ChannelDataResponse) error
	//  读取DTMF按键
	ReadDTMF(context.Context, *DTMFRequest, *DTMFResponse) error
	//  读取DTMF按键
	ReadDigits(context.Context, *DigitsRequest, *DigitsResponse) error
	// 语音识别
	DetectSpeech(context.Context, *DetectRequest, *DetectResponse) error
	// 停止语音识别
	StopDetectSpeech(context.Context, *StopDetectRequest, *Response) error
	// 回铃音检测
	RingBackDetection(context.Context, *RingBackDetectionRequest, *Response) error
	// 人脸识别
	DetectFace(context.Context, *DetectFaceRequest, *Response) error
	// 发送DTMF
	SendDTMF(context.Context, *SendDTMFRequest, *Response) error
	// 发送SIP INFO
	SendINFO(context.Context, *SendINFORequest, *Response) error
	// 执行原生APP
	NativeApp(context.Context, *NativeRequest, *NativeResponse) error
	// 执行原生API
	NativeAPI(context.Context, *NativeAPIRequest, *NativeResponse) error
	// 执行原生JSAPI
	NativeJSAPI(context.Context, *NativeJSRequest, *NativeJSResponse) error
	// 状态
	JStatus(context.Context, *JStatusRequest, *JStatusResponse) error
	// 获取会议信息
	ConferenceInfo(context.Context, *ConferenceInfoRequest, *ConferenceInfoResponse) error
	// 获取全部会议信息
	ConferenceList(context.Context, *ConferenceListRequest, *ConferenceListResponse) error
	//呼叫中心FIFO队列（先入先出）
	FIFO(context.Context, *FIFORequest, *FIFOResponse) error
	//呼叫中心Callcenter
	Callcenter(context.Context, *CallcenterRequest, *CallcenterResponse) error
	//会议Conference
	Conference(context.Context, *ConferenceRequest, *ConferenceResponse) error
	//会议AI
	AI(context.Context, *AIRequest, *AIResponse) error
	//HttAPI
	HttAPI(context.Context, *HttAPIRequest, *HttAPIResponse) error
	//Lua
	Lua(context.Context, *LuaRequest, *LuaResponse) error
	// Node Register
	Register(context.Context, *Request, *Response) error
}

func RegisterXNodeHandler(s server.Server, hdlr XNodeHandler, opts ...server.HandlerOption) error {
	type xNode interface {
		Dial(ctx context.Context, in *DialRequest, out *DialResponse) error
		Answer(ctx context.Context, in *AnswerRequest, out *Response) error
		Accept(ctx context.Context, in *AcceptRequest, out *Response) error
		Play(ctx context.Context, in *PlayRequest, out *Response) error
		Stop(ctx context.Context, in *StopRequest, out *Response) error
		Broadcast(ctx context.Context, in *BroadcastRequest, out *Response) error
		Mute(ctx context.Context, in *MuteRequest, out *Response) error
		Record(ctx context.Context, in *RecordRequest, out *RecordResponse) error
		Hangup(ctx context.Context, in *HangupRequest, out *Response) error
		Bridge(ctx context.Context, in *BridgeRequest, out *Response) error
		ChannelBridge(ctx context.Context, in *ChannelBridgeRequest, out *Response) error
		UnBridge(ctx context.Context, in *Request, out *Response) error
		UnBridge2(ctx context.Context, in *Request, out *Response) error
		Hold(ctx context.Context, in *HoldRequest, out *Response) error
		Transfer(ctx context.Context, in *TransferRequest, out *Response) error
		ThreeWay(ctx context.Context, in *ThreeWayRequest, out *Response) error
		Echo2(ctx context.Context, in *Echo2Request, out *Response) error
		Intercept(ctx context.Context, in *InterceptRequest, out *Response) error
		Consult(ctx context.Context, in *ConsultRequest, out *Response) error
		SetVar(ctx context.Context, in *SetVarRequest, out *Response) error
		GetVar(ctx context.Context, in *GetVarRequest, out *VarResponse) error
		GetState_(ctx context.Context, in *GetStateRequest, out *StateResponse) error
		GetChannelData(ctx context.Context, in *GetChannelDataRequest, out *ChannelDataResponse) error
		ReadDTMF(ctx context.Context, in *DTMFRequest, out *DTMFResponse) error
		ReadDigits(ctx context.Context, in *DigitsRequest, out *DigitsResponse) error
		DetectSpeech(ctx context.Context, in *DetectRequest, out *DetectResponse) error
		StopDetectSpeech(ctx context.Context, in *StopDetectRequest, out *Response) error
		RingBackDetection(ctx context.Context, in *RingBackDetectionRequest, out *Response) error
		DetectFace(ctx context.Context, in *DetectFaceRequest, out *Response) error
		SendDTMF(ctx context.Context, in *SendDTMFRequest, out *Response) error
		SendINFO(ctx context.Context, in *SendINFORequest, out *Response) error
		NativeApp(ctx context.Context, in *NativeRequest, out *NativeResponse) error
		NativeAPI(ctx context.Context, in *NativeAPIRequest, out *NativeResponse) error
		NativeJSAPI(ctx context.Context, in *NativeJSRequest, out *NativeJSResponse) error
		JStatus(ctx context.Context, in *JStatusRequest, out *JStatusResponse) error
		ConferenceInfo(ctx context.Context, in *ConferenceInfoRequest, out *ConferenceInfoResponse) error
		ConferenceList(ctx context.Context, in *ConferenceListRequest, out *ConferenceListResponse) error
		FIFO(ctx context.Context, in *FIFORequest, out *FIFOResponse) error
		Callcenter(ctx context.Context, in *CallcenterRequest, out *CallcenterResponse) error
		Conference(ctx context.Context, in *ConferenceRequest, out *ConferenceResponse) error
		AI(ctx context.Context, in *AIRequest, out *AIResponse) error
		HttAPI(ctx context.Context, in *HttAPIRequest, out *HttAPIResponse) error
		Lua(ctx context.Context, in *LuaRequest, out *LuaResponse) error
		Register(ctx context.Context, in *Request, out *Response) error
	}
	type XNode struct {
		xNode
	}
	h := &xNodeHandler{hdlr}
	return s.Handle(s.NewHandler(&XNode{h}, opts...))
}

type xNodeHandler struct {
	XNodeHandler
}

func (h *xNodeHandler) Dial(ctx context.Context, in *DialRequest, out *DialResponse) error {
	return h.XNodeHandler.Dial(ctx, in, out)
}

func (h *xNodeHandler) Answer(ctx context.Context, in *AnswerRequest, out *Response) error {
	return h.XNodeHandler.Answer(ctx, in, out)
}

func (h *xNodeHandler) Accept(ctx context.Context, in *AcceptRequest, out *Response) error {
	return h.XNodeHandler.Accept(ctx, in, out)
}

func (h *xNodeHandler) Play(ctx context.Context, in *PlayRequest, out *Response) error {
	return h.XNodeHandler.Play(ctx, in, out)
}

func (h *xNodeHandler) Stop(ctx context.Context, in *StopRequest, out *Response) error {
	return h.XNodeHandler.Stop(ctx, in, out)
}

func (h *xNodeHandler) Broadcast(ctx context.Context, in *BroadcastRequest, out *Response) error {
	return h.XNodeHandler.Broadcast(ctx, in, out)
}

func (h *xNodeHandler) Mute(ctx context.Context, in *MuteRequest, out *Response) error {
	return h.XNodeHandler.Mute(ctx, in, out)
}

func (h *xNodeHandler) Record(ctx context.Context, in *RecordRequest, out *RecordResponse) error {
	return h.XNodeHandler.Record(ctx, in, out)
}

func (h *xNodeHandler) Hangup(ctx context.Context, in *HangupRequest, out *Response) error {
	return h.XNodeHandler.Hangup(ctx, in, out)
}

func (h *xNodeHandler) Bridge(ctx context.Context, in *BridgeRequest, out *Response) error {
	return h.XNodeHandler.Bridge(ctx, in, out)
}

func (h *xNodeHandler) ChannelBridge(ctx context.Context, in *ChannelBridgeRequest, out *Response) error {
	return h.XNodeHandler.ChannelBridge(ctx, in, out)
}

func (h *xNodeHandler) UnBridge(ctx context.Context, in *Request, out *Response) error {
	return h.XNodeHandler.UnBridge(ctx, in, out)
}

func (h *xNodeHandler) UnBridge2(ctx context.Context, in *Request, out *Response) error {
	return h.XNodeHandler.UnBridge2(ctx, in, out)
}

func (h *xNodeHandler) Hold(ctx context.Context, in *HoldRequest, out *Response) error {
	return h.XNodeHandler.Hold(ctx, in, out)
}

func (h *xNodeHandler) Transfer(ctx context.Context, in *TransferRequest, out *Response) error {
	return h.XNodeHandler.Transfer(ctx, in, out)
}

func (h *xNodeHandler) ThreeWay(ctx context.Context, in *ThreeWayRequest, out *Response) error {
	return h.XNodeHandler.ThreeWay(ctx, in, out)
}

func (h *xNodeHandler) Echo2(ctx context.Context, in *Echo2Request, out *Response) error {
	return h.XNodeHandler.Echo2(ctx, in, out)
}

func (h *xNodeHandler) Intercept(ctx context.Context, in *InterceptRequest, out *Response) error {
	return h.XNodeHandler.Intercept(ctx, in, out)
}

func (h *xNodeHandler) Consult(ctx context.Context, in *ConsultRequest, out *Response) error {
	return h.XNodeHandler.Consult(ctx, in, out)
}

func (h *xNodeHandler) SetVar(ctx context.Context, in *SetVarRequest, out *Response) error {
	return h.XNodeHandler.SetVar(ctx, in, out)
}

func (h *xNodeHandler) GetVar(ctx context.Context, in *GetVarRequest, out *VarResponse) error {
	return h.XNodeHandler.GetVar(ctx, in, out)
}

func (h *xNodeHandler) GetState_(ctx context.Context, in *GetStateRequest, out *StateResponse) error {
	return h.XNodeHandler.GetState_(ctx, in, out)
}

func (h *xNodeHandler) GetChannelData(ctx context.Context, in *GetChannelDataRequest, out *ChannelDataResponse) error {
	return h.XNodeHandler.GetChannelData(ctx, in, out)
}

func (h *xNodeHandler) ReadDTMF(ctx context.Context, in *DTMFRequest, out *DTMFResponse) error {
	return h.XNodeHandler.ReadDTMF(ctx, in, out)
}

func (h *xNodeHandler) ReadDigits(ctx context.Context, in *DigitsRequest, out *DigitsResponse) error {
	return h.XNodeHandler.ReadDigits(ctx, in, out)
}

func (h *xNodeHandler) DetectSpeech(ctx context.Context, in *DetectRequest, out *DetectResponse) error {
	return h.XNodeHandler.DetectSpeech(ctx, in, out)
}

func (h *xNodeHandler) StopDetectSpeech(ctx context.Context, in *StopDetectRequest, out *Response) error {
	return h.XNodeHandler.StopDetectSpeech(ctx, in, out)
}

func (h *xNodeHandler) RingBackDetection(ctx context.Context, in *RingBackDetectionRequest, out *Response) error {
	return h.XNodeHandler.RingBackDetection(ctx, in, out)
}

func (h *xNodeHandler) DetectFace(ctx context.Context, in *DetectFaceRequest, out *Response) error {
	return h.XNodeHandler.DetectFace(ctx, in, out)
}

func (h *xNodeHandler) SendDTMF(ctx context.Context, in *SendDTMFRequest, out *Response) error {
	return h.XNodeHandler.SendDTMF(ctx, in, out)
}

func (h *xNodeHandler) SendINFO(ctx context.Context, in *SendINFORequest, out *Response) error {
	return h.XNodeHandler.SendINFO(ctx, in, out)
}

func (h *xNodeHandler) NativeApp(ctx context.Context, in *NativeRequest, out *NativeResponse) error {
	return h.XNodeHandler.NativeApp(ctx, in, out)
}

func (h *xNodeHandler) NativeAPI(ctx context.Context, in *NativeAPIRequest, out *NativeResponse) error {
	return h.XNodeHandler.NativeAPI(ctx, in, out)
}

func (h *xNodeHandler) NativeJSAPI(ctx context.Context, in *NativeJSRequest, out *NativeJSResponse) error {
	return h.XNodeHandler.NativeJSAPI(ctx, in, out)
}

func (h *xNodeHandler) JStatus(ctx context.Context, in *JStatusRequest, out *JStatusResponse) error {
	return h.XNodeHandler.JStatus(ctx, in, out)
}

func (h *xNodeHandler) ConferenceInfo(ctx context.Context, in *ConferenceInfoRequest, out *ConferenceInfoResponse) error {
	return h.XNodeHandler.ConferenceInfo(ctx, in, out)
}

func (h *xNodeHandler) ConferenceList(ctx context.Context, in *ConferenceListRequest, out *ConferenceListResponse) error {
	return h.XNodeHandler.ConferenceList(ctx, in, out)
}

func (h *xNodeHandler) FIFO(ctx context.Context, in *FIFORequest, out *FIFOResponse) error {
	return h.XNodeHandler.FIFO(ctx, in, out)
}

func (h *xNodeHandler) Callcenter(ctx context.Context, in *CallcenterRequest, out *CallcenterResponse) error {
	return h.XNodeHandler.Callcenter(ctx, in, out)
}

func (h *xNodeHandler) Conference(ctx context.Context, in *ConferenceRequest, out *ConferenceResponse) error {
	return h.XNodeHandler.Conference(ctx, in, out)
}

func (h *xNodeHandler) AI(ctx context.Context, in *AIRequest, out *AIResponse) error {
	return h.XNodeHandler.AI(ctx, in, out)
}

func (h *xNodeHandler) HttAPI(ctx context.Context, in *HttAPIRequest, out *HttAPIResponse) error {
	return h.XNodeHandler.HttAPI(ctx, in, out)
}

func (h *xNodeHandler) Lua(ctx context.Context, in *LuaRequest, out *LuaResponse) error {
	return h.XNodeHandler.Lua(ctx, in, out)
}

func (h *xNodeHandler) Register(ctx context.Context, in *Request, out *Response) error {
	return h.XNodeHandler.Register(ctx, in, out)
}
